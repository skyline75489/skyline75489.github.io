<!DOCTYPE html> 
<html>
<head>
<title>Skyline75489</title>
<meta charset='utf-8'>
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
<link rel="stylesheet" href="../static/styles/github.css">
<link rel="stylesheet" href="../static/post.css">
</head>
<body>

<div class="wrapper">
<div class="header">
	<span class="blog-name">Skyline75489</span>

<a class="nav" href="../index.html">Home</a>
<a class="nav" href="about.html">About</a>
</div>
<div class="content">

<h1>Docker——不是银弹的银弹</h1>
<p>本博客一直秉承对新手友好，然而这篇文章确实需要对于服务器后端开发有一定了解。对于纯新手来说，可能难以理解，不建议没有接触过服务端开发的同学阅读。</p>
<h3>Docker 是什么，为什么要使用 Docker</h3>
<p>Docker 是什么，和为什么要使用 Docker，这两个问题，很难分开解释。</p>
<p>Docker 最核心的部分，是一个进程隔离化（沙箱化）工具，其底层依赖 Linux 的 namespace 内核机制，实现对于进程的运行环境，网络，文件系统的隔离，通过 cgroup 技术，实现对于硬件资源的分配和控制。</p>
<p>对于服务器程序来说，实现进程的沙盒化，在安全性上提升是非常明显的。服务器端程序在沙盒中只能访问到受限的资源，同时不同沙盒中的程序也不会互相影响。</p>
<p>不过这只是大家使用 Docker 的理由之一。实际上进程沙盒化的工具有很多，例如专注于客户端程序沙盒化的 <a href="https://github.com/netblue30/firejail">Firejail</a> ，以及谷歌出品的轻量级沙盒化工具 <a href="https://github.com/google/nsjail">nsjail</a> 。甚至一个简单的 unshare 命令就能实现一定程度上的进程隔离。原理上他们都是利用了 Linux 的 namespace 和 cgroup 机制。</p>
<p>Docker 做的另一件非常重要的事情是做了 Docker 镜像和容器化支持。简单说，Docker 可以把一个做好的运行环境打包成镜像，分发给别人。使用方也可以直接拉镜像下来，在 Docker 容器中运行。这样子，Docker 就不仅仅做了进程隔离，而是提供了一个非常方便的部署运行环境的工具链。事实上 Docker 几乎已经成为了现在容器化技术的事实标准。</p>
<blockquote><p>Docker 不是虚拟化技术，从任何层面上看都不是“虚拟化”，而且“容器化”。Docker 里面的进程就是实实在在的 Linux 系统进程，没有任何虚拟化过程。</p>
</blockquote>
<h3>Docker 解决了什么，Docker 不能解决什么</h3>
<p>Docker 给开发和运维人员提供了一种更加便利的部署解决方案。基于 Docker 的集群管理工具，例如 Kubernetes，是非常先进的工具，可以很方便的监控服务运行的状况，同时可以通过增加冗余避免单点失败。</p>
<p>然而 Docker 不是银弹。Docker 不能解决运维人员水平不足的问题。Docker 相对于传统部署来说，提供了便利，但是也确实增加了复杂性，有一定的学习成本。除了 Docker 本身，还有和 Docker 有关的一系列工具等，都需要去了解和学习。有了这些基础，才能正确理解和使用 Docker。</p>


</div>
</div>
<script src="../static/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>

</html>
